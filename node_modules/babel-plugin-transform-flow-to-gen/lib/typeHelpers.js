'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.combine = exports.empty = exports.garbage = exports.mock = exports.map = exports.typeAlias = exports.nullable = exports.undef = exports.shape = exports.keys = exports.tuple = exports.intersection = exports.union = exports.number = exports.string = exports.boolean = exports.literal = exports.array = exports.indexedObject = exports.plainObject = undefined;

var _testcheck = require('testcheck');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var error = function error(msg) {
  throw new Error('babel-plugin-transform-flow-to-gen/types: ' + msg);
};

var toString = Object.prototype.toString;

var isUndefined = function isUndefined(obj) {
  return typeof obj === 'undefined';
};
var isFunction = function isFunction(obj) {
  return typeof obj === 'function';
};
var isObject = function isObject(obj) {
  return !Array.isArray(obj) && typeof obj === 'object' && toString.call(obj) === '[object Object]';
};

var plainObject = exports.plainObject = function plainObject(shape) {
  if (!isObject(shape)) {
    error('types.object did not receive object as it\'s argument.');
  }

  return _testcheck.gen.object(shape);
};

var indexedObject = exports.indexedObject = function indexedObject(keyGen, valueGen) {
  return _testcheck.gen.object(keyGen, valueGen);
};

var array = exports.array = function array(type) {
  if (isUndefined(type)) {
    error('types.array did not receive an argument.');
  }

  return _testcheck.gen.array(type);
};

var literal = exports.literal = function literal(obj) {
  if (isUndefined(obj)) {
    error('types.literal did not receive an argument.');
  }

  return _testcheck.gen.return(obj);
};

var boolean = exports.boolean = function boolean() {
  return _testcheck.gen.boolean;
};

var string = exports.string = function string() {
  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;
  return _testcheck.gen.resize(size, _testcheck.gen.alphaNumString);
};

var number = exports.number = function number() {
  return _testcheck.gen.int;
};

var union = exports.union = function union(arr) {
  if (!Array.isArray(arr)) {
    error('types.union expected array as argument.');
  }

  return _testcheck.gen.oneOf(arr);
};

var intersection = exports.intersection = function intersection(arr) {
  if (!Array.isArray(arr)) {
    error('types.intersection expected array as argument.');
  }

  return arr.reduce(function (interGen, typeGen) {
    return _testcheck.gen.bind(interGen, function (inter) {
      return _testcheck.gen.map(function (type) {
        return Object.assign({}, inter, type);
      }, typeGen);
    });
  }, _testcheck.gen.return({}));
};

var tuple = exports.tuple = function tuple(arr) {
  if (!Array.isArray(arr)) {
    error('types.tuple expected array as argument.');
  }

  return arr.reduce(function (interGen, typeGen) {
    return _testcheck.gen.bind(interGen, function (inter) {
      return _testcheck.gen.map(function (type) {
        return inter.concat(type);
      }, typeGen);
    });
  }, _testcheck.gen.return([]));
};

var keys = exports.keys = function keys(type) {
  if (isUndefined(type)) {
    error('types.keys expected an argument.');
  }

  return _testcheck.gen.bind(type, function (obj) {
    if (!isObject(obj)) {
      error('types.keys expected a object generator.');
    }

    var keyss = Object.keys(obj);
    return _testcheck.gen.returnOneOf(keyss);
  });
};

var shape = exports.shape = function shape(type) {
  return _testcheck.gen.bind(array(keys(type)), function (keyss) {
    return _testcheck.gen.map(function (obj) {
      if (!isObject(obj)) {
        error('types.shape expected a object generator.');
      }

      return keyss.reduce(function (acc, key) {
        return Object.assign({}, acc, _defineProperty({}, key, obj[key]));
      }, obj);
    }, type);
  });
};

var undef = exports.undef = function undef() {
  return _testcheck.gen.undefined;
};

var nullable = exports.nullable = function nullable(type) {
  if (isUndefined(type)) {
    error('types.nullable did not receive an argument.');
  }

  return _testcheck.gen.oneOf([undef(), type]);
};

var typeAlias = exports.typeAlias = function typeAlias(fn) {
  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (!fn || !isFunction(fn.asGenerator)) {
    error('types.typeAlias expected a typeAlias as first argument. Instead got ' + JSON.stringify(fn) + '.');
  }

  return _testcheck.gen.bind(undef(), function () {
    return fn.asGenerator.apply(fn, _toConsumableArray(args));
  });
};

var map = exports.map = function map(type, mapFn) {
  if (!isFunction(mapFn)) {
    error('types.:ap expected a generator function as first argument. Instead got ' + JSON.stringify(mapFn) + '.');
  }

  return _testcheck.gen.map(mapFn, type);
};

var mock = exports.mock = function mock() {
  return _testcheck.gen.bind(undef(), function () {
    return (
      // use a jest mock if this is being run with jest
      typeof jest === 'object' ? _testcheck.gen.return(jest.fn()) : _testcheck.gen.return(function () {})
    );
  });
};

var garbage = exports.garbage = function garbage() {
  return _testcheck.gen.any;
};

var empty = exports.empty = function empty() {
  return _testcheck.gen.return({});
};

var combine = exports.combine = function combine(fn) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  function recurse(gens, vals) {
    if (gens.length === 0) {
      return literal(fn.apply(undefined, _toConsumableArray(vals)));
    }

    return _testcheck.gen.bind(gens[0], function (val) {
      return recurse(gens.slice(1), vals.concat(val));
    });
  }

  return recurse(args, []);
};