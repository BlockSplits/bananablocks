'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = genFromAST;

var _babelCore = require('babel-core');

var babel = _interopRequireWildcard(_babelCore);

var _GEN_ID = require('./GEN_ID');

var _GEN_ID2 = _interopRequireDefault(_GEN_ID);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var t = babel.types;


var expression = function expression(str, args) {
  return babel.template(str)(args).expression;
};

function typeToGen(obj) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  switch (obj.type) {
    case 'generator':
      {
        return expression(_GEN_ID2.default + '.map(ARG, CALL)', {
          ARG: genFromAST(obj.typeAlias, params),
          CALL: t.identifier(obj.caller)
        });
      }
    case 'typeAlias':
      {
        var index = -1;
        var i = 0;
        var len = params.length;

        while (i < len) {
          if (params[i].name === obj.name) {
            index = i;
            break;
          }

          i += 1;
        }

        if (index === -1) {
          // wrap in a gen.bind so that recursion is lazy
          return expression(_GEN_ID2.default + '.typeAlias(CALL, ARGS)', {
            CALL: t.identifier(obj.name),
            ARGS: t.arrayExpression(obj.args.map(function (a) {
              return genFromAST(a, params);
            }))
          });
        }

        return t.identifier(obj.name);
      }
    case 'object':
      {
        var keys = Object.keys(obj.members);

        var fromMembers = expression(_GEN_ID2.default + '.plainObject(OBJ)', {
          OBJ: t.objectExpression(keys.map(function (key) {
            return t.objectProperty(t.identifier(key), genFromAST(obj.members[key], params));
          }))
        });

        if (obj.indexers.length === 0) {
          return fromMembers;
        }

        var _obj$indexers = _slicedToArray(obj.indexers, 1),
            indexer = _obj$indexers[0];

        var fromIndexer = expression(_GEN_ID2.default + '.indexedObject(KEYS, VALUES)', {
          KEYS: genFromAST(indexer.key),
          VALUES: genFromAST(indexer.value)
        });

        return expression(_GEN_ID2.default + '.combine((a, b) => Object.assign({}, a, b), MEMBERS, INDEXER)', {
          MEMBERS: fromMembers,
          INDEXER: fromIndexer
        });
      }
    case 'typeAliasKeys':
      return expression(_GEN_ID2.default + '.array(' + _GEN_ID2.default + '.keys(OBJ))', {
        OBJ: genFromAST(obj.typeAlias, params)
      });
    case 'typeAliasShape':
      return expression(_GEN_ID2.default + '.shape(OBJ)', {
        OBJ: genFromAST(obj.typeAlias, params)
      });
    case 'array':
      return expression(_GEN_ID2.default + '.array(VAL)', {
        VAL: genFromAST(obj.elementType, params)
      });
    case 'literal':
      return t.identifier(_GEN_ID2.default + '.literal(' + JSON.stringify(obj.value) + ')');
    case 'boolean':
      return t.identifier(_GEN_ID2.default + '.boolean()');
    case 'string':
      return t.identifier(_GEN_ID2.default + '.string()');
    case 'number':
      return t.identifier(_GEN_ID2.default + '.number()');
    case 'union':
      return expression(_GEN_ID2.default + '.union(ARR)', {
        ARR: t.arrayExpression(obj.entries.map(function (val) {
          return genFromAST(val, params);
        }))
      });

    case 'intersection':
      return expression(_GEN_ID2.default + '.intersection(ARR)', {
        ARR: t.arrayExpression(obj.entries.map(function (val) {
          return genFromAST(val, params);
        }))
      });
    case 'tuple':
      return expression(_GEN_ID2.default + '.tuple(ARR)', {
        ARR: t.arrayExpression(obj.entries.map(function (val) {
          return genFromAST(val, params);
        }))
      });
    case 'function':
      return t.identifier(_GEN_ID2.default + '.mock()');
    case 'nullable':
      return expression(_GEN_ID2.default + '.nullable(OBJ)', {
        OBJ: genFromAST(obj.value, params)
      });
    case 'garbage':
      return t.identifier(_GEN_ID2.default + '.garbage()');
    default:
      return t.identifier(_GEN_ID2.default + '.undef()');
  }
}

function genFromAST(obj, params) {
  var gen = typeToGen(obj, params);

  if (obj.optional === true) {
    return expression(_GEN_ID2.default + '.nullable(OBJ)', {
      OBJ: gen
    });
  }

  return gen;
}