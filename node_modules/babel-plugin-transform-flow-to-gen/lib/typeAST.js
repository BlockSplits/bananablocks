'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = typeAST;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SPECIAL_GENERICS = {
  Array: function Array(params) {
    return { type: 'array', elementType: params[0] };
  },
  Object: function Object(params) {
    return { type: 'object', members: {}, indexers: [] };
  },
  $Gen: function $Gen(params) {
    return { type: 'generator', typeAlias: params[0], caller: params[1].name };
  },
  $Keys: function $Keys(params) {
    return { type: 'typeAliasKeys', typeAlias: params[0] };
  },
  $Shape: function $Shape(params) {
    return { type: 'typeAliasShape', typeAlias: params[0] };
  },
  $Subtype: function $Subtype(params) {
    return params[0];
  }
};

function typeAST(path) {
  var optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var type = path.type.replace('TypeAnnotation', '').toLowerCase();
  var base = { type: type, optional: optional };

  switch (type) {
    case 'generic':
      {
        var typeParameters = path.typeParameters;

        var name = path.id.name;

        var args = typeParameters && typeParameters.params ? typeParameters.params.map(function (p) {
          return typeAST(p);
        }) : [];

        if (Boolean(SPECIAL_GENERICS[name])) {
          return _extends({}, SPECIAL_GENERICS[name](args), { optional: optional });
        } else {
          return { type: 'typeAlias', optional: optional, name: name, args: args };
        }
      }
    case 'object':
      {
        var members = path.properties.reduce(function (acc, prop) {
          var key = prop.key.name;
          var opt = prop.optional;
          var value = typeAST(prop.value, opt);
          return _extends({}, acc, _defineProperty({}, key, value));
        }, {});

        var indexers = path.indexers.reduce(function (acc, index) {
          if (index.id.name !== 'key') {
            return acc;
          }

          var indexer = {
            key: typeAST(index.key),
            value: typeAST(index.value)
          };

          return [].concat(_toConsumableArray(acc), [indexer]);
        }, []);

        return _extends({}, base, {
          members: members,
          indexers: indexers
        });
      }
    case 'array':
      return _extends({}, base, { elementType: typeAST(path.elementType) });
    case 'nullliteral':
      return { type: 'literal', optional: optional, value: null };
    case 'booleanliteral':
    case 'numericliteral':
    case 'stringliteral':
      return { type: 'literal', optional: optional, value: path.value };
    case 'intersection':
    case 'tuple':
    case 'union':
      return _extends({}, base, { entries: path.types.map(function (p) {
          return typeAST(p);
        }) });
    case 'nullable':
      return _extends({}, base, { value: typeAST(path.typeAnnotation) });
    case 'any':
    case 'mixed':
      return { type: 'garbage', optional: optional };
    // case `void`:
    // case `function`:
    // case `string`:
    // case `number`:
    // case `boolean`:
    default:
      return base;
  }
}